{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import re\n",
    "import sys\n",
    "phone_pattern ='(\\d{3}[-\\.\\s/]??\\d{3}[-\\.\\s/]??\\d{4}|\\(\\d{3}\\)\\s*\\d{3}[-\\.\\s/]??\\d{4})'\n",
    "\n",
    "# compiling the reg_ex would save sime time!\n",
    "ph_reg = re.compile(phone_pattern)\n",
    "\n",
    "\n",
    "def check_for_phone(patient,note,chunk, output_handle):\n",
    "    \"\"\"\n",
    "    Inputs:\n",
    "        - patient: Patient Number, will be printed in each occurance of personal information found\n",
    "        - note: Note Number, will be printed in each occurance of personal information found\n",
    "        - chunk: one whole record of a patient\n",
    "        - output_handle: an opened file handle. The results will be written to this file.\n",
    "            to avoid the time intensive operation of opening and closing the file multiple times\n",
    "            during the de-identification process, the file is opened beforehand and the handle is passed\n",
    "            to this function. \n",
    "    Logic:\n",
    "        Search the entire chunk for phone number occurances. Find the location of these occurances \n",
    "        relative to the start of the chunk, and output these to the output_handle file. \n",
    "        If there are no occurances, only output Patient X Note Y (X and Y are passed in as inputs) in one line.\n",
    "        Use the precompiled regular expression to find phones.\n",
    "    \"\"\"\n",
    "    # The perl code handles texts a bit differently, \n",
    "    # we found that adding this offset to start and end positions would produce the same results\n",
    "    offset = 27\n",
    "\n",
    "    # For each new note, the first line should be Patient X Note Y and then all the personal information positions\n",
    "    output_handle.write('Patient {}\\tNote {}\\n'.format(patient,note))\n",
    "\n",
    "    # search the whole chunk, and find every position that matches the regular expression\n",
    "    # for each one write the results: \"Start Start END\"\n",
    "    # Also for debugging purposes display on the screen (and don't write to file) \n",
    "    # the start, end and the actual personal information that we found\n",
    "    for match in ph_reg.finditer(chunk):\n",
    "                \n",
    "            # debug print, 'end=\" \"' stops print() from adding a new line\n",
    "            print(patient, note,end=' ')\n",
    "            print((match.start()-offset),match.end()-offset, match.group())\n",
    "                \n",
    "            # create the string that we want to write to file ('start start end')    \n",
    "            result = str(match.start()-offset) + ' ' + str(match.start()-offset) +' '+ str(match.end()-offset) \n",
    "            \n",
    "            # write the result to one line of output\n",
    "            output_handle.write(result+'\\n')\n",
    "\n",
    "            \n",
    "            \n",
    "def deid_phone(text_path= 'id.text', output_path = 'phone.phi'):\n",
    "    \"\"\"\n",
    "    Inputs: \n",
    "        - text_path: path to the file containing patient records\n",
    "        - output_path: path to the output file.\n",
    "    \n",
    "    Outputs:\n",
    "        for each patient note, the output file will start by a line declaring the note in the format of:\n",
    "            Patient X Note Y\n",
    "        then for each phone number found, it will have another line in the format of:\n",
    "            start start end\n",
    "        where the start is the start position of the detected phone number string, and end is the detected\n",
    "        end position of the string both relative to the start of the patient note.\n",
    "        If there is no phone number detected in the patient note, only the first line (Patient X Note Y) is printed\n",
    "        to the output\n",
    "    Screen Display:\n",
    "        For each phone number detected, the following information will be displayed on the screen for debugging purposes \n",
    "        (these will not be written to the output file):\n",
    "            start end phone_number\n",
    "        where `start` is the start position of the detected phone number string, and `end` is the detected end position of the string\n",
    "        both relative to the start of patient note.\n",
    "    \n",
    "    \"\"\"\n",
    "    # start of each note has the patter: START_OF_RECORD=PATIENT||||NOTE||||\n",
    "    # where PATIENT is the patient number and NOTE is the note number.\n",
    "    start_of_record_pattern = '^start_of_record=(\\d+)\\|\\|\\|\\|(\\d+)\\|\\|\\|\\|$'\n",
    "\n",
    "    # end of each note has the patter: ||||END_OF_RECORD\n",
    "    end_of_record_pattern = '\\|\\|\\|\\|END_OF_RECORD$'\n",
    "\n",
    "    # open the output file just once to save time on the time intensive IO\n",
    "    with open(output_path,'w+') as output_file:\n",
    "        with open(text_path) as text:\n",
    "            # initilize an empty chunk. Go through the input file line by line\n",
    "            # whenever we see the start_of_record pattern, note patient and note numbers and start \n",
    "            # adding everything to the 'chunk' until we see the end_of_record.\n",
    "            chunk = ''\n",
    "            for line in text:\n",
    "                record_start = re.findall(start_of_record_pattern,line,flags=re.IGNORECASE)\n",
    "                if len(record_start):\n",
    "                    patient, note = record_start[0]\n",
    "                chunk += line\n",
    "\n",
    "                # check to see if we have seen the end of one note\n",
    "                record_end = re.findall(end_of_record_pattern, line,flags=re.IGNORECASE)\n",
    "\n",
    "                if len(record_end):\n",
    "                    # Now we have a full patient note stored in `chunk`, along with patient numerb and note number\n",
    "                    # pass all to check_for_phone to find any phone numbers in note.\n",
    "                    check_for_phone(patient,note,chunk.strip(), output_file)\n",
    "                    \n",
    "                    # initialize the chunk for the next note to be read\n",
    "                    chunk = ''\n",
    "                \n",
    "if __name__== \"__main__\":\n",
    "        \n",
    "    \n",
    "    \n",
    "    deid_phone(sys.argv[1], sys.argv[2])\n",
    "    "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
